<?xml version="1.0" encoding="utf-8"?>

    <!--

    BigBlueButton open source conferencing system - http://www.bigbluebutton.org/

    Copyright (c) 2012 BigBlueButton Inc. and by respective authors (see below).

    This program is free software; you can redistribute it and/or modify it under the
        terms of the GNU Lesser General Public License as published by the Free Software
        Foundation; either version 3.0 of the License, or (at your option) any later
        version.

        BigBlueButton is distributed in the hope that it will be useful, but WITHOUT ANY
        WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A
        PARTICULAR PURPOSE. See the GNU Lesser General Public License for more details.

        You should have received a copy of the GNU Lesser General Public License along
        with BigBlueButton; if not, see
        <http://www.gnu.org/licenses/>
    .

    -->

        <CustomMdiWindow xmlns="org.bigbluebutton.common.*"
            xmlns:mx="http://www.adobe.com/2006/mxml"
            initialize="init()"
            horizontalScrollPolicy="off"
            verticalScrollPolicy="off"
            creationComplete="onCreationComplete()"
            implements="org.bigbluebutton.common.IBbbModuleWindow"
            title=""
            xmlns:mate="http://mate.asfusion.com/" styleNameFocus="videoDockStyleFocus"
            layout="absolute" visible="false" styleNameNoFocus="videoDockStyleNoFocus"
            horizontalAlign="center"
            verticalAlign="middle"
            resize="onChildAdd()">
            <!--title="{ResourceUtil.getInstance().getString('bbb.videodock.title')}"-->


            <mate:Listener type="{LocaleChangeEvent.LOCALE_CHANGED}" method="localeChanged" />
            <mate:Listener type="{ShortcutEvent.FOCUS_VIDEO_WINDOW}" method="focusWindow" />
            <mate:Listener type="{ShortcutEvent.MINIMIZE_DOCK}" method="remoteMinimize" />
            <mate:Listener type="{ShortcutEvent.MAXIMIZE_DOCK}" method="remoteMaximize" />
            <mate:Listener type="{PrivateChatEvent.PRIVATE_CHAT}" method="privateChatVisible" />

            <mx:Script>
                <![CDATA[
			import com.asfusion.mate.events.Dispatcher;
			import com.adobe.crypto.SHA1;
			
			import mx.events.ChildExistenceChangedEvent;
			
			import flexlib.mdi.containers.MDIWindow;
			
			import org.bigbluebutton.common.Images;
			import org.bigbluebutton.common.LogUtil;
			import org.bigbluebutton.common.events.CloseWindowEvent;
			import org.bigbluebutton.common.events.DragWindowEvent;
			import org.bigbluebutton.common.events.LocaleChangeEvent;
			import org.bigbluebutton.common.events.OpenWindowEvent;
			import org.bigbluebutton.core.BBB;
			import org.bigbluebutton.core.UsersUtil;
			import org.bigbluebutton.core.events.ConnectAppEvent;
			import org.bigbluebutton.core.events.LockControlEvent;
			import org.bigbluebutton.core.events.PrivateChatEvent;
			import org.bigbluebutton.core.managers.UserManager;
			import org.bigbluebutton.main.events.ShortcutEvent;
			import org.bigbluebutton.main.model.users.BBBUser;
			import org.bigbluebutton.main.model.users.Conference;
			import org.bigbluebutton.main.model.users.events.RaiseHandEvent;
			import org.bigbluebutton.main.views.MainCanvas;
			import org.bigbluebutton.modules.videoconf.business.VideoWindowItf;
			import org.bigbluebutton.modules.videoconf.events.OpenVideoWindowEvent;
			import org.bigbluebutton.modules.videoconf.events.UserTalkingEvent;
			import org.bigbluebutton.modules.videoconf.model.VideoConfOptions;
			import org.bigbluebutton.util.i18n.ResourceUtil;
			import org.bigbluebutton.main.views.MainApplicationShell;
			import org.bigbluebutton.main.api.JSLog;

			import org.bigbluebutton.main.model.ConferenceParameters;
			import org.bigbluebutton.main.model.modules.ModulesProxy;
			import org.bigbluebutton.modules.videoconf.business.VideoProxy;



			public var sharerUserID:String;
      public var salt:String ="eb7c5c72b730112644db1a12db84267e";//"2d75e011711511fb656d2eadf7a5ff29";
//"2c245e2705612ae069ad6497c73665ec";
      public var moderatorPW:String = "prof123";
	  public var attendeePW:String = "student123";
	  public var privateModeratorPW:String = "privateprof123";
	  public var privateAttendeePW:String = "privatestudent123";
			private static const LOG:String = "VideoDock  - ";
			private var childrenDimension:Dictionary = new Dictionary();
			private var borderColor:String;
			private var minChildAspectRatio:Number;
			// the mutable array is used to change the order of the dock children
			private var mutableChildrenArray:Array = new Array();
			
			private var _prioritizeWindow:Boolean = false;
			private var priorityWindow:VideoWindowItf = null;
			// the priority video will fit a portion of the dock that is represented by this weight
			// bigger the weight, bigger will be the window and less space the other windows will have
			private var priorityWindowWeight:Number = 2/3;
			
			private var options:DockOptions = new DockOptions();
			private var confOptions:VideoConfOptions = new VideoConfOptions();
			private var dispatcher:Dispatcher;			
			private var keyCombos:Object;
			
			[Bindable] 
			private var baseIndex:int;
			
			private function init():void{
				baseIndex = options.baseTabIndex;
			}
			
			private var images:Images = new Images();
      
			[Bindable]
			private var backgroundImage:Class = images.video_dock_bg;
      
			private function onCreationComplete():void {				
				this.showCloseButton = false;		
				this.showControls = options.showControls;
        
				this.minWidth = options.width;
				this.minHeight = options.height;
				this.maxWidth = this.parent.width;
				this.maxHeight = this.parent.height;
				
				this.width = this.minWidth;
				this.height = this.minHeight;
				
				addEventListener(ChildExistenceChangedEvent.CHILD_ADD, onChildAdd);			
				addEventListener(ChildExistenceChangedEvent.CHILD_REMOVE, onChildRemove);
				
				dispatcher = new Dispatcher();
				hotkeyCapture();
				
				resourcesChanged();
				
				titleBarOverlay.tabIndex = baseIndex;
				
				minimizeBtn.tabIndex = baseIndex+1;
				maximizeRestoreBtn.tabIndex = baseIndex+2;
				
				closeBtn.tabIndex = baseIndex+3;
				
				//showPrivateChatButtonVideoDock();
				showNextManagerButton();
				
				if (options.maximize) this.maximize();
        
		        var gDispatcher:Dispatcher = new Dispatcher();
		        var evt:ConnectAppEvent = new ConnectAppEvent(ConnectAppEvent.CONNECT_VIDEO_APP);
		        gDispatcher.dispatchEvent(evt);
			}
			
			private function remoteMinimize(e:ShortcutEvent):void{
				if (!minimized){
					this.minimize();
				}
			}
			
			private function remoteMaximize(e:ShortcutEvent):void{
				if (!maximized && !minimized){
					this.maximize();
				}
				else{
					this.restore();
				}				
			}

		    private function loadKeyCombos(modifier:String):void {
				keyCombos = new Object(); // always start with a fresh array
			    keyCombos[modifier+(ResourceUtil.getInstance().getString('bbb.shortcutkey.general.maximize') as String)] = ShortcutEvent.MAXIMIZE_DOCK;
				keyCombos[modifier+(ResourceUtil.getInstance().getString('bbb.shortcutkey.general.minimize') as String)] = ShortcutEvent.MINIMIZE_DOCK;
			}
		
		    private function hotkeyCapture():void{
		      this.addEventListener(KeyboardEvent.KEY_DOWN, handleKeyDown);
		      ResourceUtil.getInstance().addEventListener(Event.CHANGE, localeChanged); // Listen for locale changing
		    }
		
			// Handle general-access hotkeys, regardless of what window the user is focused in
		    private function handleKeyDown(e:KeyboardEvent) :void {
		      var modifier:String = ExternalInterface.call("determineModifier");
			  loadKeyCombos(modifier);			  
			  var keyPress:String = (e.ctrlKey  ? "control+" : "") + (e.shiftKey ? "shift+"   : "") +
		                            (e.altKey   ? "alt+"     : "") + e.keyCode;		                              
		      if (keyCombos[keyPress]) {
		        dispatcher.dispatchEvent(new ShortcutEvent(keyCombos[keyPress]));
		      }
		    }
			
			private function focusWindow(e:ShortcutEvent):void{
				focusManager.setFocus(titleBarOverlay);
			}
		
			private function localeChanged(e:Event):void{
				resourcesChanged();
			}
			
			/**
			 *	The windows docked are organized in a MxN grid equally divided.
			 *	Then, the aspect ratio of the cells is the equal of the window
			 *	with lower aspect ratio. For example, if there are two windows, 
			 *	one 4x3 and one 16x9, the aspect ratio of the grid cells will be
			 *	4x3, to better fit all the windows. The aspect ratio of the grid
			 *	cells is updated every time a window is added or removed. 
			 */
			private function updateMinAspectRatio(children:Array):void {
				minChildAspectRatio = 0;
				for each(var window:VideoWindowItf in children) {
				    const windowAspectRatio:Number = (window.width - VideoWindowItf.PADDING_HORIZONTAL) / (window.height - VideoWindowItf.PADDING_VERTICAL);
				    if (minChildAspectRatio == 0 || windowAspectRatio < minChildAspectRatio)
				        minChildAspectRatio = windowAspectRatio;				        
				}
				LogUtil.debug("Using aspect ratio grid = " + minChildAspectRatio);
			}
			
			private function onChildAdd(e:ChildExistenceChangedEvent = null):void {
				if (e != null) {
					mutableChildrenArray.push(getChildren().pop());
					updateMinAspectRatio(mutableChildrenArray);
				}
				
				if (options.oneAlwaysBigger && !_prioritizeWindow)
					prioritizeAnyWindow();
				
				updateChildrenDimensions(mutableChildrenArray);
			}
			
			private function onChildRemove(e:ChildExistenceChangedEvent = null):void {
				var index:int = mutableChildrenArray.indexOf(e.relatedObject);
				if (index != -1)
					mutableChildrenArray.splice(index, 1);
				
				if (e.relatedObject == priorityWindow || mutableChildrenArray.length <= 1)
					deprioritizeWindow();
					
				updateMinAspectRatio(mutableChildrenArray);
				updateChildrenDimensions(mutableChildrenArray);
			}
			
			public function getPrefferedPosition():String {
				//return MainCanvas.BOTTOM_RIGHT;
				return options.position;
			}
					
			private function saveWindowDimensions(window:MDIWindow):void {
				var dimensions:Object = {width:window.width, height:window.height};
				childrenDimension[window] = dimensions;
			}
			
			private function restoreWindowDimensions(window:MDIWindow):void {
				window.width = childrenDimension[window].width;
				window.height = childrenDimension[window].height;
			}
			
			private function repositionWindow(window:MDIWindow):void {
				// \TODO reposition the window correctly between the windows
				// one idea is to use a "shadow" window
				// setChildIndex(window, ?);
			}
			
			private function isVideoWindow(window:Object):Boolean {
				return (getQualifiedSuperclassName(window) == "org.bigbluebutton.modules.videoconf.business::VideoWindowItf")
			}
			
			private function onCloseWindow(e:CloseWindowEvent):void {
				// it should not just undock the window, it should close the window forever
				if (isVideoWindow(e.window) && this.contains(e.window as VideoWindowItf)) {
          this.removeChild(e.window as VideoWindowItf);
        }
					
			}
			
			private function onOpenWindow(e:OpenVideoWindowEvent):void {
				if (isVideoWindow(e.window) && options.autoDock) {
          addVideoChild(e.window as VideoWindowItf);
        }					
			}
			
			private function addVideoChild(window:VideoWindowItf):void {
				if (this.contains(window))
					return;
				
				/**
				 * Check if the window is visible. Right now, a publisher window can be made invisible by setting
				 * a param in config.xml. If the window is invisible, don't add it. We'll have to do this properly
				 * when we refactor to remove the window UIs. We should just be adding Videos here instead of windows.
				 * But for now, this is good enough.
				 */
				if (! window.visible) return;
				
				
				
				saveWindowDimensions(window);
				
				window.minimizeBtn.visible = false;
				window.maximizeRestoreBtn.visible = false;
				window.resizable = false;
       			window.draggable = false;

				window.addEventListener(MouseEvent.CLICK, onWindowClick);
				window.addEventListener(UserTalkingEvent.TALKING, onTalking);
				
				var e:CloseWindowEvent = new CloseWindowEvent();
				e.window = window;
				dispatchEvent(e);
				
				this.addChild(window);
			}
			
			override public function close(event:MouseEvent = null):void {
        for each(var windowItf:VideoWindowItf in mutableChildrenArray) {
          windowItf.close();
        }
        
				removeAllChildren();
				super.close(event);
			}
			
			private function updateChildrenDimensions(children:Array):void {
				var padding:int = 0;
				
				if (children.length == 0) return;
				
				const horizontalGap:int = getStyle("horizontalGap");
				const verticalGap:int = getStyle("verticalGap");
				
				var availableWidth:int = this.width - this.borderMetrics.left - this.borderMetrics.right;
				if (!UsersUtil.amIModerator()){
					padding = 60;
				}
				var availableHeight:int = this.height-padding - this.borderMetrics.top - this.borderMetrics.bottom;
				
				var borderTop:int = 0;
				var borderLeft:int = 0;
				
				if (_prioritizeWindow) {
					// the first window will be prioritized
					priorityWindow = children[0];
					
					// if the aspect ratio of the dock is smaller than the window (like 1:1 against 16:9)
					// the window will be on top of the dock 
					if (availableWidth / availableHeight < priorityWindow.width / priorityWindow.height
							|| options.layout == DockOptions.LAYOUT_HANGOUT) {
						priorityWindow.width = availableWidth;
						priorityWindow.updateHeight();
						if (priorityWindow.height > availableHeight * priorityWindowWeight) {
							priorityWindow.height = availableHeight * priorityWindowWeight;
							priorityWindow.updateWidth();
						}
						priorityWindow.y = 0;
						priorityWindow.x = (availableWidth - priorityWindow.width) / 2;
						availableHeight -= (priorityWindow.height + verticalGap);
						borderTop += priorityWindow.height + verticalGap;
					} else {
						// the window will be on left of the dock 
						priorityWindow.height = availableHeight;
						priorityWindow.updateWidth();
						if (priorityWindow.width > availableWidth * priorityWindowWeight) {
							priorityWindow.width = availableWidth * priorityWindowWeight;
							priorityWindow.updateHeight();
						}
						priorityWindow.y = (availableHeight - priorityWindow.height) / 2;
						priorityWindow.x = 0;
						availableWidth -= (priorityWindow.width + horizontalGap);
						borderLeft += priorityWindow.width + horizontalGap;
					}
				}
				
				var childWidth:int = 0;
				var childHeight:int = 0;
				var nRows:Number = 0;
				var nColumns:Number = 0;
				
				// we would like to maximize the window size
				for (var rows:Number = 1; rows <= children.length - (_prioritizeWindow? 1: 0); ++rows) {
					var columns:Number = Math.ceil((children.length - (_prioritizeWindow? 1: 0))/ rows);
					var maxWidth:int = Math.floor((availableWidth - horizontalGap * (columns - 1)) / columns) - VideoWindowItf.PADDING_HORIZONTAL;
					var maxHeight:int = Math.floor((availableHeight - verticalGap * (rows - 1)) / rows) - VideoWindowItf.PADDING_VERTICAL;
					
					// the possible dimensions shouldn't be less or equal 0 (it could happen with many videos)
					if (maxWidth <= 0 || maxHeight <=0)
						continue;
					
					var width:int = maxWidth;
					var height:int = maxHeight;
					
					if (maxWidth / maxHeight > minChildAspectRatio)
						width = Math.floor(maxHeight * minChildAspectRatio);
					else
						height = Math.floor(maxWidth / minChildAspectRatio);
					
					if (width > childWidth) {
						childWidth = width;
						childHeight = height;
						nRows = rows;
						nColumns = columns;
					}
				}                        
				
				childWidth += VideoWindowItf.PADDING_HORIZONTAL;
				childHeight += VideoWindowItf.PADDING_VERTICAL;

				const horizontalBorder:int = availableWidth - nColumns * childWidth - (nColumns - 1) * horizontalGap;
				const verticalBorder:int = availableHeight - nRows * childHeight - (nRows - 1) * verticalGap;
				// this couple of lines will center the priority window on the available space for it
				if (_prioritizeWindow) {
					if (priorityWindow.x == 0) {
						priorityWindow.x = horizontalBorder / 3;
						borderTop += verticalBorder / 2;
						borderLeft += horizontalBorder * (2 / 3);
					} else {
						priorityWindow.y = verticalBorder / 3;  
						borderTop += verticalBorder * (2 / 3);
						borderLeft += horizontalBorder / 2;
					}
				} else {
					// if there's no priority window, the border will be only around the little windows
					borderTop += verticalBorder / 2;
					borderLeft += horizontalBorder / 2;
				}
									
				for (var childIndex:int = (_prioritizeWindow? 1: 0); childIndex < children.length; ++childIndex) {
					var window:VideoWindowItf = children[childIndex];
					const wWidth:int = childWidth;
					const wHeight:int = childHeight;
					
					window.width = wWidth;
					window.updateHeight();
					
					if (window.height > wHeight) {
						window.height = wHeight;
						window.updateWidth();
					}
					
					// the extra padding is used to center the windows with higher aspect ratio
					const horizontalExtraPadding:int = (wWidth - window.width) / 2;
					const verticalExtraPadding:int = (wHeight - window.height+40) / 2;
					
					var row:int = (childIndex - (_prioritizeWindow? 1: 0)) / nColumns;
					var column:int = (childIndex - (_prioritizeWindow? 1: 0)) % nColumns;
					
					window.y = row * (wHeight + verticalGap) + borderTop + verticalExtraPadding;;
					window.x = column * (wWidth + horizontalGap) + borderLeft + horizontalExtraPadding;
				} 
			}
			
			protected function onWindowClick(event:MouseEvent = null):void {
				prioritizeWindow(event.currentTarget);
			}
			
			private function prioritizeWindow(window:Object):void {
				if (mutableChildrenArray.length <= 1
						|| options.layout == DockOptions.LAYOUT_NONE)
					return;
				
				if (_prioritizeWindow && window == priorityWindow && !options.oneAlwaysBigger) {
					deprioritizeWindow();
				} else {
					var index:int = mutableChildrenArray.indexOf(window);
					if (index != -1) {
						mutableChildrenArray[index] = mutableChildrenArray[0];
						mutableChildrenArray[0] = window;
						_prioritizeWindow = true;
					}
				}
				updateChildrenDimensions(mutableChildrenArray);
			}
			
			protected function onTalking(event:UserTalkingEvent):void {
				prioritizeTalking(event.currentTarget);
			}
			
			private function prioritizeTalking(window:Object):void {
				if (mutableChildrenArray.length <= 1
						|| options.layout == DockOptions.LAYOUT_NONE)
					return;
				
				if (window == priorityWindow) //window already prioritized
					return;
				
				var index:int = mutableChildrenArray.indexOf(window);
				if (index != -1) {
					mutableChildrenArray[index] = mutableChildrenArray[0];
					mutableChildrenArray[0] = window;
					_prioritizeWindow = true;
				}
				
				updateChildrenDimensions(mutableChildrenArray);
			}
			
			private function prioritizeAnyWindow():void {
				if (mutableChildrenArray.length > 0)
					prioritizeWindow(mutableChildrenArray[0]);
			}
			
			private function deprioritizeWindow():void {
				if (options.oneAlwaysBigger && mutableChildrenArray.length > 1)
					prioritizeAnyWindow();
				else {
					_prioritizeWindow = false;
				}
			}
			
			override protected function resourcesChanged():void{
				super.resourcesChanged();
				this.title = "";//ResourceUtil.getInstance().getString('bbb.videodock.title');
				
				if (titleBarOverlay != null) {
					titleBarOverlay.accessibilityName = ResourceUtil.getInstance().getString('bbb.videoDock.titleBar');
				}
				
				if (windowControls != null) {
					maximizeRestoreBtn.accessibilityName = ResourceUtil.getInstance().getString('bbb.video.maximizeRestoreBtn.accessibilityName');
					minimizeBtn.accessibilityName = ResourceUtil.getInstance().getString('bbb.video.minimizeBtn.accessibilityName');
				}
			}			
			
			private function showPrivateChatButtonVideoDock():void {
				var me:BBBUser = UserManager.getInstance().getConference().getMyUser();
				if(!me.isPrivateChat&&!UsersUtil.amIModerator()){
							privateChatBtnVideoDock.visible = true;	
				}else{
					privateChatBtnVideoDock.visible = false;	
				}
			}
			
			public function privateChatVisible(e:PrivateChatEvent):void{
				showPrivateChatButtonVideoDock();
			}
			
			private function onPrivateChatClicked(event:Event):void {
				event.stopImmediatePropagation();
				
				//var e:CoreEvent = new CoreEvent(EventConstants.START_PRIVATE_CHAT);
				//e.message.chatWith = sharerUserID;
				var e:RaiseHandEvent = new RaiseHandEvent(RaiseHandEvent.RAISE_HAND);
				
				if (UserManager.getInstance().getConference().isMyHandRaised) {
					e.raised = false;
					//raiseHandBtn.accessibilityName = ResourceUtil.getInstance().getString('bbb.users.raiseHandBtn.toolTip2');
				} else {
					e.raised = true;
					privateChatBtnVideoDock.setStyle("fillColors", new Array(0x78797a, 0x78797a));
					privateChatBtnVideoDock.setStyle("fillAlphas", new Array(1.0, 1.0));
					var me:BBBUser = UserManager.getInstance().getConference().getMyUser();
					var presenter:BBBUser = UserManager.getInstance().getConference().getPresenter();
					presenter.presenterForPrivateChat = presenter.userID;
					me.presenterForPrivateChat = presenter.userID;
					var gd:Dispatcher = new Dispatcher();
					gd.dispatchEvent(e);
					//raiseHandBtn.accessibilityName = ResourceUtil.getInstance().getString('bbb.users.raiseHandBtn.toolTip');
				}

			}

			//------------------------------------------------------------------------------------------------------
	//------------------------------------------------------------------------------------------------------
	//------------------------------------------------------------------------------------------------------
	//------------------------------------------------------------------------------------------------------
	//------------------------------------------------------------------------------------------------------

	  private function onNextManagerClicked(event:Event):void {
			event.stopImmediatePropagation();

			//var gd:Dispatcher = new Dispatcher();

			//gd.dispatchEvent(e);
			getNextManager();

	  }

	  public function getNextManager():void {
		//event.stopImmediatePropagation();

		//var gd:Dispatcher = new Dispatcher();

		var urlParametersRequest:String = "/bigbluebutton/api/getMeetings?checksum=";
		var urlParameters:String = "getMeetings" + salt;
		var checksum:String = SHA1.hash(urlParameters);
		urlParametersRequest = urlParametersRequest+checksum;

		var request:URLRequest = new URLRequest(urlParametersRequest);

		request.method = URLRequestMethod.GET;

		var urlLoader:URLLoader;

		urlLoader = new URLLoader();
		urlLoader.addEventListener(Event.COMPLETE, handleComplete);
		urlLoader.load(request);
	  }

		private function handleComplete(e:Event):void{
			var xml:XML = new XML(e.target.data);
			var logData:Object = new Object();


			var returncode:String = xml.returncode;
			LogUtil.debug("return code: " + returncode);
			if (returncode != 'SUCCESS') {
				LogUtil.debug("failed to load any dynamic info to add to the UI");
				JSLog.debug("failed to load any dynamic info to add to the UI " + xml, logData);
				return;
			}

			var currentMeetingID:String = UsersUtil.getExternalMeetingID();
			var currentMeetingTime:String;

			var meetings:XMLList = xml.meetings.children();
			var meetingsMap:Object = new Object();
			var times:Array = new Array();
			//var booleanModeratorPW:Boolean;
			for each(var meetingXML:XML in meetings) {
			//	if (meetingXML.moderatorPW!=privateModeratorPW){
			//
			//	}
				trace ("~~Before If~~~~ID - " + meetingXML.meetingID + "   passwd - " + meetingXML.moderatorPW + "    moderatorPW=privateModeratorPW " + (meetingXML.moderatorPW!=privateModeratorPW));
				if(meetingXML.running=="true" && meetingXML.moderatorPW!=privateModeratorPW){
					trace ("~~After If ~~~~ID - " + meetingXML.meetingID + "   passwd - " + meetingXML.moderatorPW + "    moderatorPW=privateModeratorPW " + (meetingXML.moderatorPW!=privateModeratorPW));
					var meetingID:String = meetingXML.meetingID;
					var createTime:String = meetingXML.createTime;
					meetingsMap[createTime]=meetingID;
					times.push(createTime);
					if(meetingID==currentMeetingID){
						currentMeetingTime = createTime;
					}
				}
			}
			times.sort();

			var indexList:int = 0;

			indexList=times.indexOf(currentMeetingTime);

			if (indexList==-1||indexList==(times.length-1)){
				indexList = 0;
			} else{
				indexList = indexList + 1;
			}
			//trace(LOG + "meetingid: "+currentMeetingID+"   time "+currentMeetingTime + "    array " + times + "   indexList " + indexList + "   MeetingID" + meetingsMap[times[indexList]] + "   meetingsMap" + meetingsMap);
			var nextMitingId:String = meetingsMap[times[indexList]];
			trace(LOG + "========nextMitingId : "+nextMitingId);

			JSLog.debug("========nextMitingId : "+nextMitingId, logData);
			//------------------get manager id from meeting info
			var urlParametersRequest:String = "/bigbluebutton/api/getMeetingInfo?meetingID="+nextMitingId+"&password="+moderatorPW+"&checksum=";
			var urlParameters:String = "getMeetingInfomeetingID="+nextMitingId+"&password="+moderatorPW + salt;
			var checksum:String = SHA1.hash(urlParameters);
			urlParametersRequest = urlParametersRequest+checksum;

			var request:URLRequest = new URLRequest(urlParametersRequest);
			trace(LOG + "========+++url : "+urlParametersRequest);
			request.method = URLRequestMethod.GET;

			var urlLoader:URLLoader;

			urlLoader = new URLLoader();
			urlLoader.addEventListener(Event.COMPLETE,function(e:Event) : void { getNetxMeetingInfo(e, nextMitingId) } );
			urlLoader.load(request);
		}

		private function getNetxMeetingInfo(e:Event,nextMitingId:String):void{
			var xml:XML = new XML(e.target.data);
			LogUtil.debug("load URL complete: " + xml);
			var logData:Object = new Object();

	  		JSLog.debug("load URL complete: " + xml, logData);
			var returncode:String = xml.returncode;
			LogUtil.debug("return code: " + returncode);
			if (returncode != 'SUCCESS') {
				LogUtil.debug("failed to load any dynamic info to add to the UI");
				return;
			}
			var voicebridge:String = xml.voiceBridge;
			redirectToNextManager(nextMitingId,voicebridge);
		}

		private function redirectToNextManager(nextManager:String,voicebridge:String):void {

			var  me:String = UsersUtil.getMyUsername();
			var urlParametersRequest:String = "/bigbluebutton/api/join?meetingID=" + nextManager + "&fullName=" + me + "&redirect=false&password=" + attendeePW + "&checksum=";
			var urlParameters:String = "joinmeetingID=" + nextManager + "&fullName=" + me + "&redirect=false&password=" + attendeePW + salt;

			var checksum:String = SHA1.hash(urlParameters);
			urlParametersRequest = urlParametersRequest+checksum;

			var request:URLRequest = new URLRequest(urlParametersRequest);
			request.method = URLRequestMethod.GET;

			var urlLoader:URLLoader;

			urlLoader = new URLLoader();
			urlLoader.addEventListener(Event.COMPLETE, function(e:Event) : void { handleLoginToNextManagerRoom(e, nextManager,voicebridge) });
			urlLoader.load(request);

		}

		private function handleLoginToNextManagerRoom(e:Event,nextManager:String,voicebridge:String):void{
			var xml:XML = new XML(e.target.data);
			LogUtil.debug("load URL complete: " + xml);
			var logData:Object = new Object();

	  		JSLog.debug("load URL complete: " + xml, logData);
			var returncode:String = xml.returncode;
			LogUtil.debug("return code: " + returncode);
			if (returncode != 'SUCCESS') {
				JSLog.debug("failed to load any dynamic info to add to the UI: " + xml, logData);

				return;
			}

			var newMeetingId:String = xml.meeting_id;
			var newUserId:String = xml.user_id;
			var newAuthToken:String = xml.auth_token;

			UserManager.getInstance().getConference().setMyRoom(newMeetingId);
			UserManager.getInstance().getConference().setMyAuthToken(newAuthToken);


			UserManager.getInstance().getConference().setMyUserid(newUserId+"_2");

			UserManager.getInstance().getConference().externalMeetingID = nextManager;
			UserManager.getInstance().getConference().meetingName = nextManager;
			UserManager.getInstance().getConference().internalMeetingID = newMeetingId;
			UserManager.getInstance().getConference().externalUserID = newUserId;
			UserManager.getInstance().getConference().voiceBridge = voicebridge;

			BBB.initConnectionManager().connectToNextRoom();
			new ModulesProxy();

	  	}

		//------------------------------------------------------------------------------------------------------
		//------------------------------------------------------------------------------------------------------
		//------------------------------------------------------------------------------------------------------
		//------------------------------------------------------------------------------------------------------
		//------------------------------------------------------------------------------------------------------

			private function showNextManagerButton():void {

				var me:BBBUser = UserManager.getInstance().getConference().getMyUser();
				if(!me.isPrivateChat&&!UsersUtil.amIModerator()){
					nextManagerBtn.visible = true;
				} else {
					nextManagerBtn.visible = false;

				}
			}

		]]>
            </mx:Script>

            <mate:Listener type="{OpenVideoWindowEvent.OPEN_VIDEO_WINDOW_EVENT}" method="onOpenWindow" />
            <mate:Listener type="{CloseWindowEvent.CLOSE_WINDOW_EVENT}" method="onCloseWindow" />
            <mx:Button label="{ResourceUtil.getInstance().getString('bbb.videodock.nextManagerBtn')}" id="nextManagerBtn" toolTip="{ResourceUtil.getInstance().getString('bbb.videodock.nextManagerBtn.toolTip')}" paddingTop="2" bottom="1" right="5" click="onNextManagerClicked(event)"/>
            <mx:Button visible="false" label="{ResourceUtil.getInstance().getString('bbb.videodock.privateChatBtn')}" id="privateChatBtnVideoDock" toolTip="{ResourceUtil.getInstance().getString('bbb.videodock.privateChatBtn.toolTip')}" paddingTop="2" bottom="1" right="5" click="onPrivateChatClicked(event)"/>

        </CustomMdiWindow>
